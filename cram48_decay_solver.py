"""
CRAM-48 Decay Solver
---------------------
Uses the 48th-order Chebyshev Rational Approximation Method (CRAM-48)
to compute the radioactive decay of a single nuclide and compares it
to the analytical solution.

"""

import numpy as np
from scipy.sparse import csc_matrix, eye
from scipy.sparse.linalg import spsolve

# CRAM-48 coefficients (from literature / OpenMC)
c48_theta = np.array([
    -4.465731934165702e+1 + 6.233225190695437e+1j,
    -5.284616241568964e+0 + 4.057499381311059e+1j,
    -8.867715667624458e+0 + 4.325515754166724e+1j,
    +3.493013124279215e+0 + 3.281615453173585e+1j,
    +1.564102508858634e+1 + 1.558061616372237e+1j,
    +1.742097597385893e+1 + 1.076629305714420e+1j,
    -2.834466755180654e+1 + 5.492841024648724e+1j,
    +1.661569367939544e+1 + 1.316994930024688e+1j,
    +8.011836167974721e+0 + 2.780232111309410e+1j,
    -2.056267541998229e+0 + 3.794824788914354e+1j,
    +1.449208170441839e+1 + 1.799988210051809e+1j,
    +1.853807176907916e+1 + 5.974332563100539e+0j,
    +9.932562704505182e+0 + 2.532823409972962e+1j,
    -2.244223871767187e+1 + 5.179633600312162e+1j,
    +8.590014121680897e-1 + 3.536456194294350e+1j,
    -1.286192925744479e+1 + 4.600304902833652e+1j,
    +1.164596909542055e+1 + 2.287153304140217e+1j,
    +1.806076684783089e+1 + 8.368200580099821e+00j,
    +5.870672154659249e+00 + 3.029700159040121e+01j,
    -3.542938819659747e+01 + 5.834381701800013e+01j,
    +1.901323489060250e+01 + 1.194282058271408e+00j,
    +1.885508331552577e+01 + 3.583428564427879e+00j,
    -1.734689708174982e+01 + 4.883941101108207e+01j,
    +1.316284237125190e+01 + 2.042951874827759e+01j
], dtype=np.complex128)

c48_alpha = np.array([
    +6.387380733878774e+2 - 6.743912502859256e+2j,
    +1.909896179065730e+2 - 3.973203432721332e+2j,
    +4.236195226571914e+2 - 2.041233768918671e+3j,
    +4.645770595258726e+2 - 1.652917287299683e+3j,
    +7.765163276752433e+2 - 1.783617639907328e+4j,
    +1.907115136768522e+3 - 5.887068595142284e+4j,
    +2.909892685603256e+3 - 9.953255345514560e+3j,
    +1.944772206620450e+2 - 1.427131226068449e+3j,
    +1.382799786972332e+5 - 3.256885197214938e+6j,
    +5.628442079602433e+3 - 2.924284515884309e+4j,
    +2.151681283794220e+2 - 1.121774011188224e+3j,
    +1.324720240514420e+3 - 6.370088443140973e+4j,
    +1.617548476343347e+4 - 1.008798413156542e+6j,
    +1.112729040439685e+2 - 8.837109731680418e+1j,
    +1.074624783191125e+2 - 1.457246116408180e+2j,
    +8.835727765158191e+1 - 6.388286188419360e+1j,
    +9.354078136054179e+1 - 2.195424319460237e+2j,
    +9.418142823531573e+1 - 6.719055740098035e+2j,
    +1.040012390717851e+2 - 1.693747595553868e+2j,
    +6.861882624343235e+1 - 1.177598523430493e+1j,
    +8.766654491283722e+1 - 4.596464999363902e+3j,
    +1.056007619389650e+2 - 1.738294585524067e+3j,
    +7.738987569039419e+1 - 4.311715386228984e+1j,
    +1.041366366475571e+2 - 2.777743732451969e+2j
], dtype=np.complex128)

c48_alpha0 = 2.258038182743983e-47

# Decay parameters
decay_const = 3.124e-17   # U-235 decay constant (1/s)
t = 100.0                 # Time in seconds
N0 = 1.0                  # Initial number density

# Matrix setup
A = csc_matrix([[-decay_const]])
I = eye(1, format='csc')
y = np.array([N0], dtype=np.complex128)

# CRAM-48 evaluation
for a, th in zip(c48_alpha, c48_theta):
    y += 2.0 * np.real(a * spsolve(t * A - th * I, y))

y *= c48_alpha0
cram_result = np.real(y[0])
analytic_result = N0 * np.exp(-decay_const * t)

# Output
print(f"[CRAM-48] At t = {t:.1f} s -> Result: {cram_result:.5e}, Analytic: {analytic_result:.5e}, Difference: {abs(cram_result - analytic_result):.2e}")
